/* dashboard.js */

let currentUser = null;
let links = [];
if (path === '/dashboard' || path === '/dashboard/') {
	showSection('profile');
	return;
}

// Extract section from path
const section = path.split('/').pop();
if (['profile', 'links', 'media', 'analytics'].includes(section)) {
	showSection(section);
} else {
	if (avatarPreview) avatarPreview.src = currentUser.avatar || '/assets/khxzilogo.png';

	const themeSelect = document.getElementById('themeSelect');
	if (themeSelect) themeSelect.value = currentUser.theme || 'red-black';

	// Links & Media
	links = currentUser.links || [];
	selectedMedia.bgMusic = currentUser.bgMusic || '';
	selectedMedia.bgVideo = currentUser.bgVideo || '';
	selectedMedia.cursor = currentUser.cursor || '';

	renderLinks();
	updatePreview();

	// Discord Status
	const discordStatus = document.getElementById('discordStatus');
	if (discordStatus) {
		if (currentUser.discord && currentUser.discord.id) {
			discordStatus.innerHTML = `
				<div style="display: flex; align-items: center; gap: 1rem; background: rgba(88, 101, 242, 0.2); padding: 1rem; border-radius: 8px; border: 1px solid #5865F2;">
					<img src="https://cdn.discordapp.com/avatars/${currentUser.discord.id}/${currentUser.discord.avatar}.png" 
						onerror="this.src='https://cdn.discordapp.com/embed/avatars/0.png'"
						style="width: 40px; height: 40px; border-radius: 50%;">
					<div>
						<div style="font-weight: bold;">${currentUser.discord.username}</div>
						<div style="font-size: 0.8rem; opacity: 0.8;">Connected</div>
					</div>
					<button onclick="unlinkDiscord()" class="btn btn-secondary" style="margin-left: auto; font-size: 0.8rem; padding: 0.4rem 0.8rem;">Unlink</button>
				</div>
			`;
		} else {
			discordStatus.innerHTML = `
				<button id="linkDiscordBtn" class="btn" style="background: #5865F2; color: white; width: 100%;">
					Connect Discord
				</button>
			`;
			// Re-attach listener since we replaced innerHTML
			document.getElementById('linkDiscordBtn').addEventListener('click', initiateDiscordLink);
		}
	}
}

function initiateDiscordLink() {
	const clientId = '1442843317590036562';
	const redirectUri = window.location.hostname === 'localhost'
		? 'http://localhost:3001/auth/discord/callback'
		: 'https://khxzi.com/auth/discord/callback';
	const scope = 'identify guilds email guilds.join connections';

	window.location.href = `https://discord.com/oauth2/authorize?client_id=${clientId}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&scope=${encodeURIComponent(scope)}`;
}

async function unlinkDiscord() {
	if (!confirm('Are you sure you want to unlink your Discord account?')) return;

	try {
		// We need an API endpoint for this, assuming generic updateProfile can handle clearing it 
		// or we create a specific one. For now, let's try updating profile with null discord.
		// Actually, usually specific endpoint is safer.
		// Let's assume we can just update the user object via a new endpoint or existing one.
		// Since we don't have a specific unlink endpoint in the viewed files, I'll use a placeholder alert for now
		// or try to update profile with empty discord object if the backend supports it.

		alert('Unlinking not yet implemented in backend.');
	} catch (err) {
		console.error(err);
	}
}

async function loadSystemMedia() {
	try {
		const res = await fetchAPI('/api/system/media');

		// Helper to render media items
		const renderItems = (containerId, items, type) => {
			const container = document.getElementById(containerId);
			if (!container) return;
			container.innerHTML = '';

			items.forEach(url => {
				const div = document.createElement('div');
				div.className = `media-item ${selectedMedia[type] === url ? 'selected' : ''}`;
				div.textContent = url.split('/').pop();
				div.onclick = () => selectMedia(type, url, div);
				container.appendChild(div);
			});
		};

		renderItems('systemMusic', res.music || [], 'bgMusic');
		renderItems('systemVideo', res.videos || [], 'bgVideo');
		renderItems('systemCursor', res.cursors || [], 'cursor');

	} catch (err) {
		console.error('Failed to load system media', err);
	}
}

function selectMedia(type, url, element) {
	selectedMedia[type] = url;
	// Update UI
	const container = element.parentElement;
	container.querySelectorAll('.media-item').forEach(el => el.classList.remove('selected'));
	element.classList.add('selected');

	// Auto save or just update preview? Let's update preview.
	updatePreview();
}

async function loadAnalytics() {
	try {
		const data = await fetchAPI(`/api/analytics/user/${currentUser.username}`);
		const totalViewsEl = document.getElementById('totalViews');
		if (totalViewsEl) totalViewsEl.textContent = data.views;

		const clicksContainer = document.getElementById('linkClicks');
		if (clicksContainer) {
			clicksContainer.innerHTML = '';
			if (data.links) {
				for (const [label, count] of Object.entries(data.links)) {
					const div = document.createElement('div');
					div.style.display = 'flex';
					div.style.justifyContent = 'space-between';
					div.style.padding = '0.5rem';
					div.style.borderBottom = '1px solid #333';
					div.innerHTML = `<span>${label}</span> <span style="color: var(--primary-color)">${count}</span>`;
					clicksContainer.appendChild(div);
				}
			}
		}
	} catch (err) {
		console.error('Failed to load analytics', err);
	}
}

function renderLinks() {
	const container = document.getElementById('linksContainer');
	if (!container) return;
	container.innerHTML = '';

	links.forEach((link, index) => {
		const div = document.createElement('div');
		div.className = 'link-item';
		div.draggable = true;
		div.dataset.index = index;
		div.innerHTML = `
            <div class="drag-handle">☰</div>
            <input type="text" placeholder="Label" value="${link.label}" onchange="updateLink(${index}, 'label', this.value)">
            <input type="text" placeholder="URL" value="${link.url}" onchange="updateLink(${index}, 'url', this.value)">
            <button class="btn-secondary" onclick="removeLink(${index})" style="padding: 0.5rem;">×</button>
        `;

		// Drag events
		div.addEventListener('dragstart', handleDragStart);
		div.addEventListener('dragover', handleDragOver);
		div.addEventListener('drop', handleDrop);
		div.addEventListener('dragenter', handleDragEnter);
		div.addEventListener('dragleave', handleDragLeave);

		container.appendChild(div);
	});
}

function updateLink(index, field, value) {
	links[index][field] = value;
	updatePreview();
}

function addLink() {
	links.push({ label: 'New Link', url: 'https://' });
	renderLinks();
	updatePreview();
}

function removeLink(index) {
	links.splice(index, 1);
	renderLinks();
	updatePreview();
}

// Drag and Drop Logic (Links)
let dragSrcEl = null;
function handleDragStart(e) {
	dragSrcEl = this;
	e.dataTransfer.effectAllowed = 'move';
	e.dataTransfer.setData('text/html', this.innerHTML);
	this.classList.add('dragging');
}
function handleDragOver(e) {
	if (e.preventDefault) e.preventDefault();
	e.dataTransfer.dropEffect = 'move';
	return false;
}
function handleDragEnter(e) { this.classList.add('over'); }
function handleDragLeave(e) { this.classList.remove('over'); }
function handleDrop(e) {
	if (e.stopPropagation) e.stopPropagation();
	if (dragSrcEl !== this) {
		const srcIndex = parseInt(dragSrcEl.dataset.index);
		const targetIndex = parseInt(this.dataset.index);
		const temp = links[srcIndex];
		links[srcIndex] = links[targetIndex];
		links[targetIndex] = temp;
		renderLinks();
		updatePreview();
	}
	return false;
}

// File Drag & Drop Logic
function setupDragDrop() {
	const avatarZone = document.getElementById('avatarDropZone');
	const avatarInput = document.getElementById('avatarInput');

	if (avatarZone && avatarInput) {
		avatarZone.onclick = () => avatarInput.click();

		avatarZone.ondragover = (e) => {
			e.preventDefault();
			avatarZone.classList.add('dragover');
		};

		avatarZone.ondragleave = () => avatarZone.classList.remove('dragover');

		avatarZone.ondrop = async (e) => {
			e.preventDefault();
			avatarZone.classList.remove('dragover');
			const file = e.dataTransfer.files[0];
			if (file) uploadFile(file, 'avatar');
		};

		avatarInput.onchange = (e) => {
			const file = e.target.files[0];
			if (file) uploadFile(file, 'avatar');
		};
	}

	// Similar setup could be done for music/video inputs if needed
}

async function uploadFile(file, type) {
	const formData = new FormData();
	formData.append('file', file);

	try {
		const res = await fetch(`/api/upload?type=${type}`, {
			method: 'POST',
			body: formData
		});
		const data = await res.json();
		if (data.success) {
			if (type === 'avatar') {
				document.getElementById('avatarPreview').src = data.path;
				updatePreview();
			}
		}
	} catch (err) {
		alert('Upload failed');
	}
}

async function saveProfile() {
	const bioInput = document.getElementById('bioInput');
	const avatarPreview = document.getElementById('avatarPreview');
	const themeSelect = document.getElementById('themeSelect');

	const bio = bioInput ? bioInput.value : '';
	const avatar = avatarPreview ? avatarPreview.src : '';
	const theme = themeSelect ? themeSelect.value : 'red-black';

	try {
		await fetchAPI('/api/user/updateProfile', {
			method: 'POST',
			body: JSON.stringify({
				bio,
				avatar,
				bgMusic: selectedMedia.bgMusic,
				bgVideo: selectedMedia.bgVideo,
				cursor: selectedMedia.cursor
			})
		});

		await fetchAPI('/api/user/updateLinks', {
			method: 'POST',
			body: JSON.stringify({ links })
		});

		await fetchAPI('/api/user/updateTheme', {
			method: 'POST',
			body: JSON.stringify({ theme })
		});

		alert('Profile Saved Successfully!');
	} catch (err) {
		alert('Failed to save profile: ' + err.message);
	}
}

function setupEventListeners() {
	const saveProfileBtn = document.getElementById('saveProfileBtn');
	if (saveProfileBtn) saveProfileBtn.addEventListener('click', saveProfile);

	const saveLinksBtn = document.getElementById('saveLinksBtn');
	if (saveLinksBtn) saveLinksBtn.addEventListener('click', saveProfile);

	const publishBtn = document.getElementById('publishBtn');
	if (publishBtn) {
		publishBtn.addEventListener('click', async () => {
			try {
				await fetchAPI('/api/profile/publish', { method: 'POST' });
				alert('Profile published!');
				window.open(`/@${currentUser.username}`, '_blank');
			} catch (err) {
				alert('Failed to publish: ' + err.message);
			}
		});
	}

	const shareBtn = document.getElementById('shareBtn');
	if (shareBtn) {
		shareBtn.addEventListener('click', () => {
			const profileUrl = `${window.location.origin}/@${currentUser.username}`;
			if (navigator.share) {
				navigator.share({
					title: `${currentUser.username}'s Profile`,
					text: `Check out my profile on Khxzi!`,
					url: profileUrl
				});
			} else {
				navigator.clipboard.writeText(profileUrl);
				alert('Profile link copied to clipboard!');
			}
		});
	}

	const themeSelect = document.getElementById('themeSelect');
	if (themeSelect) themeSelect.addEventListener('change', updatePreview);

	const bioInput = document.getElementById('bioInput');
	if (bioInput) bioInput.addEventListener('input', updatePreview);
}

function updatePreview() {
	const previewFrame = document.getElementById('previewFrame');
	if (!previewFrame) return;

	const bioInput = document.getElementById('bioInput');
	const avatarPreview = document.getElementById('avatarPreview');
	const themeSelect = document.getElementById('themeSelect');

	const data = {
		username: currentUser.username,
		bio: bioInput ? bioInput.value : '',
		avatar: avatarPreview ? avatarPreview.src : '',
		links: links,
		theme: themeSelect ? themeSelect.value : 'red-black',
		bgMusic: selectedMedia.bgMusic,
		bgVideo: selectedMedia.bgVideo,
		cursor: selectedMedia.cursor,
		discord: currentUser.discord
	};
	previewFrame.contentWindow.postMessage(data, '*');

	console.log('Preview updated with:', data);
}

function setupDragDrop() {
	const dropZones = document.querySelectorAll('.drop-zone');
	dropZones.forEach(zone => {
		zone.addEventListener('dragover', e => {
			e.preventDefault();
			zone.classList.add('drag-over');
		});
		zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
		zone.addEventListener('drop', handleDrop);
	});
}

function handleDrop(e) {
	e.preventDefault();
	const dropZone = e.currentTarget;
	const file = e.dataTransfer.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = function (e) {
		const base64 = e.target.result.split(',')[1];
		const type = file.type.split('/')[0];
		const name = file.name;

		const data = {
			type,
			name,
			base64
		};

		const previewFrame = document.getElementById('previewFrame');
		if (!previewFrame) return;

		previewFrame.contentWindow.postMessage(data, '*');
	};
	reader.readAsDataURL(file);
}
}